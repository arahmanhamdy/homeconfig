#!/bin/zsh

autoload colors
colors
GIT=/usr/bin/git

# ----------------------------------------------------------------------
# various git scripts

gitize() {
    $GIT init \
    && $GIT add . \
    && $GIT commit -a -m"initial commit" \
    && $GIT gc
}

# ----------------------------------------------------------------------
# The following implements a caching mechanism for git information.
# The RPROMPT executes get_git_bprompt_info() and include the output...
#
#   setopt prompt_subst
#   RPROMPT="$(get_git_prompt_info)"
#
export __ZSH_GIT_DIR=
export __ZSH_GIT_BRANCH=
export __ZSH_GIT_STATE=

# http://blog.madism.org/index.php/2008/05/07/173-git-prompt
parse_git() {
    local git_dir branch

    psvar=()
    git_dir_=$($GIT rev-parse --git-dir 2> /dev/null)
    if [ -z "$git_dir_" ]; then
        export __ZSH_GIT_DIR=
        return
    fi
    git_dir=$(readlink -f $git_dir_)
    if test -d "$git_dir/../.dotest"; then
        if test -f "$git_dir/../.dotest/rebasing"; then
            __ZSH_GIT_STATE="rebase"
        elif test -f "$git_dir/../.dotest/applying"; then
            __ZSH_GIT_STATE="am"
        else
            __ZSH_GIT_STATE="am/rebase"
        fi
        branch="$($GIT symbolic-ref HEAD 2>/dev/null)"
    elif test -f "$git_dir/.dotest-merge/interactive"; then
        __ZSH_GIT_STATE="rebase -i"
        branch="$(cat "$git_dir/.dotest-merge/head-name")"
    elif test -d "$git_dir/.dotest-merge"; then
        __ZSH_GIT_STATE="rebase -m"
        branch="$(cat "$git_dir/.dotest-merge/head-name")"
    elif test -f "$git_dir/MERGE_HEAD"; then
        __ZSH_GIT_STATE="merge"
        branch="$($GIT symbolic-ref HEAD 2>/dev/null)"
    else
        test -f "$git_dir/BISECT_LOG" && __ZSH_GIT_STATE="bisect"
        branch="$($GIT symbolic-ref HEAD 2>/dev/null)" || \
            branch="$($GIT describe --exact-match HEAD 2>/dev/null)" || \
            branch="$(cut -c1-7 "$git_dir/HEAD")..."
    fi

    __ZSH_GIT_FULL_DIR=${git_dir:h}
    __ZSH_GIT_DIR="${__ZSH_GIT_FULL_DIR/$HOME/~}"
    __ZSH_GIT_BRANCH="${branch#refs/heads/}"

    export __ZSH_GIT_FULL_DIR
    export __ZSH_GIT_DIR
    export __ZSH_GIT_BRANCH
    export __ZSH_GIT_STATE
}

# on each chdir update the cached git variable(s)
chpwd_functions+='zsh_git_chpwd_update_vars'
precmd_functions+='zsh_git_precmd_update_vars'

zsh_git_chpwd_update_vars() {
    parse_git
}
zsh_git_precmd_update_vars() {
    if [ -n "$(fc -l -m 'git*' -1 -1)" ]; then
        parse_git
    fi
}
# this function returns the current git branch
# it takes as argument a string with printf like arguments:
#   '%P'     path to top of repository
#   '%p'     path to top of repository, with s/$HOME/~/
#   '%b'     current branch
#   '%s'     state of rebase/merge/bisect/am
#   '%%'     a '%' character
# providing no arguments is equivalent to "%p %b %s".
get_git_prompt_info() {
        test -n "$__ZSH_GIT_DIR" || return
        local def fmt res
        def='%p %b %s'
        fmt=$@
        res=${fmt:-$def}
        res=${res//\%P/$__ZSH_GIT_FULL_DIR }
        res=${res//\%p/$__ZSH_GIT_DIR }
        res=${res//\%b/$__ZSH_GIT_BRANCH }
        test -n "$__ZSH_GIT_STATE" && \
                res=${res//\%s/$__ZSH_GIT_STATE }
        res=${res//\%%/%}

        echo -n "${res}"
}

